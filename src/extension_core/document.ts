import * as vscode from 'vscode';
import { promisify } from 'util';
import { Worker } from 'worker_threads';
import * as fs from 'fs';
declare function requirefs(_name: "fs"): typeof fs;

import { SignalId, NetlistId, VaporviewDocumentDelegate} from './viewer_provider';
// Import the code generated by wit2ts
// If this file is not present, run `npm run generate:model` to generate it
// See GETTING_STARTED.md for more details
import { filehandler } from './filehandler';

export type NetlistIdTable = NetlistIdRef[];
export type NetlistIdRef = {
  netlistItem: NetlistItem;
  displayedItem: NetlistItem | undefined;
  signalId: SignalId;
};
type WaveformTopMetadata = {
  timeTableLoaded: boolean;
  moduleCount: number;
  netlistIdCount: number;
  signalIdCount: number;
  timeEnd:     number;
  chunkTime:   number;
  chunkCount:  number;
  timeScale:   number;
  defaultZoom: number;
  timeUnit:    string;
};

interface fsWrapper {
  loadStatic: boolean;
  fd: number;
  fileSize: number;
  bufferSize: number;
  fileData?: Uint8Array;
  loadFile: (uri: vscode.Uri, fileType: string) => void;
  readSlice: (fd: number, buffer: Uint8Array, offset: number, length: number, position: number) => number;
  close: (fd: number) => void;
}

// Scopes
const moduleIcon    = new vscode.ThemeIcon('chip',                   new vscode.ThemeColor('charts.purple'));
const taskIcon      = new vscode.ThemeIcon('debug-stack-frame',      new vscode.ThemeColor('charts.blue'));
const funcIcon      = new vscode.ThemeIcon('symbol-module',          new vscode.ThemeColor('charts.blue'));
const beginIcon     = new vscode.ThemeIcon('debug-start',            new vscode.ThemeColor('charts.blue'));
const forkIcon      = new vscode.ThemeIcon('repo-forked',            new vscode.ThemeColor('charts.blue'));
const structIcon    = new vscode.ThemeIcon('symbol-structure', new vscode.ThemeColor('charts.blue'));
const unionIcon     = new vscode.ThemeIcon('surround-with',    new vscode.ThemeColor('charts.blue'));
const classIcon     = new vscode.ThemeIcon('symbol-misc',      new vscode.ThemeColor('charts.blue'));
const interfaceIcon = new vscode.ThemeIcon('debug-disconnect', new vscode.ThemeColor('charts.purple'));
const packageIcon   = new vscode.ThemeIcon('package',          new vscode.ThemeColor('charts.purple'));
const scopeIcon     = new vscode.ThemeIcon('symbol-module',    new vscode.ThemeColor('charts.purple'));

export function createScope(name: string, type: string, path: string, netlistId: number, scopeOffsetIdx: number) {
  
  let icon = scopeIcon;
  const typename = type.toLocaleLowerCase();
  switch (typename) {
    case 'module':           {icon = moduleIcon; break;}
    case 'task':             {icon = taskIcon; break;}
    case 'function':         {icon = funcIcon; break;}
    case 'begin':            {icon = beginIcon; break;}
    case 'fork':             {icon = forkIcon; break;}
    case 'generate':         {icon = scopeIcon; break;}
    case 'struct':           {icon = structIcon; break;}
    case 'union':            {icon = unionIcon; break;}
    case 'class':            {icon = classIcon; break;}
    case 'interface':        {icon = interfaceIcon; break;}
    case 'package':          {icon = packageIcon; break;}
    case 'program':          {icon = scopeIcon; break;}
    case 'vhdlarchitecture': {icon = scopeIcon; break;}
    case 'vhdlprocedure':    {icon = taskIcon; break;}
    case 'vhdlfunction':     {icon = funcIcon; break;}
    case 'vhdlrecord':       {icon = scopeIcon; break;}
    case 'vhdlprocess':      {icon = scopeIcon; break;}
    case 'vhdlblock':        {icon = scopeIcon; break;}
    case 'vhdlforgenerate':  {icon = scopeIcon; break;}
    case 'vhdlifgenerate':   {icon = scopeIcon; break;}
    case 'vhdlgenerate':     {icon = scopeIcon; break;}
    case 'vhdlpackage':      {icon = packageIcon; break;}
    case 'ghwgeneric':       {icon = scopeIcon; break;}
    case 'vhdlarray':        {icon = scopeIcon; break;}
  }

  const module    = new NetlistItem(name, 'module', 'none', 0, 0, netlistId, name, path, 0, 0, scopeOffsetIdx, [], vscode.TreeItemCollapsibleState.Collapsed);
  module.iconPath = icon;

  return module;
}
  
function bitRangeString(msb: number, lsb: number): string {
  if (msb < 0 || lsb < 0) {return "";}
  if (msb === lsb) {return " [" + msb + "]";}
  return "[" + msb + ":" + lsb + "]";
}

// Variables
const regIcon     = new vscode.ThemeIcon('symbol-array',     new vscode.ThemeColor('charts.green'));
const wireIcon    = new vscode.ThemeIcon('symbol-interface', new vscode.ThemeColor('charts.pink'));
const intIcon     = new vscode.ThemeIcon('symbol-variable',  new vscode.ThemeColor('charts.green'));
const paramIcon   = new vscode.ThemeIcon('settings',         new vscode.ThemeColor('charts.green'));
const realIcon    = new vscode.ThemeIcon('pulse',            new vscode.ThemeColor('charts.orange'));
const defaultIcon = new vscode.ThemeIcon('file-binary',      new vscode.ThemeColor('charts.green'));
const stringIcon  = new vscode.ThemeIcon('symbol-key',       new vscode.ThemeColor('charts.yellow'));
const portIcon    = new vscode.ThemeIcon('plug',             new vscode.ThemeColor('charts.green'));
const timeIcon    = new vscode.ThemeIcon('watch',            new vscode.ThemeColor('charts.green'));

export function createVar(name: string, type: string, encoding: string, path: string, netlistId: NetlistId, signalId: SignalId, width: number, msb: number, lsb: number, isFsdb: boolean) {
  const field = bitRangeString(msb, lsb);

  // field is already included in signal name for fsdb
  if (!isFsdb) name = name + field;

  const variable = new NetlistItem(name, type, encoding, width, signalId, netlistId, name, path, msb, lsb, -1, [], vscode.TreeItemCollapsibleState.None, vscode.TreeItemCheckboxState.Unchecked);
  const typename = type.toLocaleLowerCase();
  let icon;

  switch (typename) {
    case 'event':           {icon = defaultIcon; break;}
    case 'integer':         {icon = intIcon; break;}
    case 'parameter':       {icon = paramIcon; break;}
    case 'real':            {icon = realIcon; break;}
    case 'reg':             {icon = defaultIcon; break;}
    case 'supply0':         {icon = defaultIcon; break;}
    case 'supply1':         {icon = defaultIcon; break;}
    case 'time':            {icon = timeIcon; break;}
    case 'tri':             {icon = defaultIcon; break;}
    case 'triand':          {icon = defaultIcon; break;}
    case 'trior':           {icon = defaultIcon; break;}
    case 'trireg':          {icon = defaultIcon; break;}
    case 'tri0':            {icon = defaultIcon; break;}
    case 'tri1':            {icon = defaultIcon; break;}
    case 'wand':            {icon = defaultIcon; break;}
    case 'wire':            {icon = wireIcon; break;}
    case 'wor':             {icon = defaultIcon; break;}
    case 'string':          {icon = stringIcon; break;}
    case 'port':            {icon = portIcon; break;}
    case 'sparsearray':     {icon = defaultIcon; break;}
    case 'realtime':        {icon = timeIcon; break;}
    case 'bit':             {icon = defaultIcon; break;}
    case 'logic':           {icon = defaultIcon; break;}
    case 'int':             {icon = intIcon; break;}
    case 'shortint':        {icon = intIcon; break;}
    case 'longint':         {icon = intIcon; break;}
    case 'byte':            {icon = defaultIcon; break;}
    case 'enum':            {icon = defaultIcon; break;}
    case 'shortreal':       {icon = defaultIcon; break;}
    case 'boolean':         {icon = defaultIcon; break;}
    case 'bitvector':       {icon = defaultIcon; break;}
    case 'stdlogic':        {icon = defaultIcon; break;}
    case 'stdlogicvector':  {icon = defaultIcon; break;}
    case 'stdulogic':       {icon = defaultIcon; break;}
    case 'stdulogicvector': {icon = defaultIcon; break;}
  }

  variable.iconPath = icon;
  if ((typename === 'wire') || (typename === 'reg') || (icon === defaultIcon)) {
    if (width > 1) {variable.iconPath = regIcon;}
    else           {variable.iconPath = wireIcon;}
  }

  return variable;
}

const nodeFsWrapper: fsWrapper = {
  loadStatic: false,
  fd: 0,
  fileSize: 0,
  bufferSize: 60 * 1024,
  loadFile: async (uri: vscode.Uri, fileType: string) => {
    const open                 = promisify(fs.open);
    const stats                = fs.statSync(uri.fsPath);
    nodeFsWrapper.fd           = await open(uri.fsPath, 'r');
    nodeFsWrapper.fileSize     = stats.size;
    const fstMaxStaticLoadSize = vscode.workspace.getConfiguration('vaporview').get('fstMaxStaticLoadSize');
    const maxStaticSize        = Number(fstMaxStaticLoadSize) * 1048576;
    nodeFsWrapper.loadStatic   = (stats.size < maxStaticSize);

    // For VCD files, we stream the file, so we want to use a larger buffer size
    // For FST files, we want to use Rust's default buffer size of 8192 bytes,
    // but we don't care about buffer size if we statically load the file
    if (fileType === 'fst' && nodeFsWrapper.loadStatic === false) {
      nodeFsWrapper.bufferSize = 8192;
      vscode.window.showInformationMessage(
        uri.fsPath + ' is larger than the max static load size of ' + fstMaxStaticLoadSize +
        ' MB. File will be loaded dynamically. You can configure the max load size in your extension settings');
    }
  },
  readSlice: fs.readSync,
  close: promisify(fs.close)
};

const wroskpaceFsWrapper: fsWrapper = {
  loadStatic: true,
  fd: 0,
  fileSize: 0,
  bufferSize: 60 * 1024,
  loadFile: async (uri: vscode.Uri, fileType: string) => {
    const stats                 = await vscode.workspace.fs.stat(uri);
    wroskpaceFsWrapper.fileData = await vscode.workspace.fs.readFile(uri);
    wroskpaceFsWrapper.fileSize = stats.size;
  },
  readSlice: (fd: number, buffer: Uint8Array, offset: number, length: number, position: number) => {
    buffer.set(wroskpaceFsWrapper.fileData!.subarray(position, position + length), offset);
    return length;
  },
  close: (fd: number) => {}
};

// Adapted from the VScode hex editor extension source
const getFsWrapper = async (uri: vscode.Uri): Promise<fsWrapper> => {

  if (uri.scheme === "file") {
    try {
      const fs = requirefs("fs");
      const fileStats = await fs.promises.stat(uri.fsPath);

      if (fileStats.isFile()) {
        return nodeFsWrapper;
      }
    } catch {
      // probably not node.js, or file does not exist
    }
  }

  return wroskpaceFsWrapper;
};

// #region VaporviewDocument
export class VaporviewDocument extends vscode.Disposable implements vscode.CustomDocument {

  private readonly _uri: vscode.Uri;
  private fileReader: fsWrapper;
  // Hierarchy
  public treeData:         NetlistItem[] = [];
  public displayedSignals: NetlistItem[] = [];
  private _netlistIdTable: NetlistIdTable = [];
  // Wasm
  private readonly _delegate: VaporviewDocumentDelegate;
  public _wasmWorker: Worker;
  public wasmApi: any;
  private fileBuffer: Uint8Array;
  // Fsdb
  public isFsdb: boolean = false;
  private fsdbAddon: any;
  private fsdbTopModuleCount: number = 0;
  // Webview
  public webviewPanel: vscode.WebviewPanel | undefined = undefined;
  private _webviewInitialized: boolean = false;
  public metadata:   WaveformTopMetadata = {
    timeTableLoaded: false,
    moduleCount:    0,
    netlistIdCount: 0,
    signalIdCount:  0,
    timeEnd:     0,
    chunkTime:   128,
    chunkCount:  0,
    timeScale:   1,
    defaultZoom: 1,
    timeUnit:    "ns",
  };
  public webviewContext = {
    markerTime: null,
    altMarkerTime: null,
    selectedSignal: null,
    displayedSignals: [],
    zoomRatio: 1,
    scrollLeft: 0,
    numberFormat: "hexadecimal",
  };

  static async create(
    uri: vscode.Uri,
    backupId: string | undefined,
    wasmWorker: Worker,
    wasmModule: WebAssembly.Module,
    delegate: VaporviewDocumentDelegate,
  ): Promise<VaporviewDocument | PromiseLike<VaporviewDocument>> {

    const fsWrapper = await getFsWrapper(uri);
    const document  = new VaporviewDocument(uri, fsWrapper, wasmWorker, delegate);
    await document.createWasmApi(wasmModule);
    document.load();
    return document;
  }

  private constructor(
    uri: vscode.Uri,
    fileReader: fsWrapper,
    _wasmWorker: Worker,
    delegate: VaporviewDocumentDelegate,
  ) {
    super(() => this.dispose());
    this._uri        = uri;
    this._wasmWorker = _wasmWorker;
    this._delegate   = delegate;
    this.fileBuffer  = new Uint8Array(65536);
    this.fileReader = fileReader;
  }

  private async load() {

    const fileType = this.uri.fsPath.split('.').pop()?.toLocaleLowerCase() || '';
    if (fileType === 'fsdb') {
      if (process.platform !== 'linux') {
        vscode.window.showErrorMessage("FSDB support is currently available on Linux only.");
        return;
      }
      this.isFsdb = true;
      this.loadFsdb();
    } else {
      this._load(fileType);
    }
  }

  // Load VCD, FST, GHW files using WASM
  private async _load(fileType: string) {
    await this.fileReader.loadFile(this.uri, fileType);
    await vscode.window.withProgress({
      location: vscode.ProgressLocation.Notification,
      title: "Parsing Netlist for " + this.uri.fsPath,
      cancellable: false
    }, async () => {
      await this.wasmApi.loadfile(BigInt(this.fileReader.fileSize), this.fileReader.fd, this.fileReader.loadStatic, this.fileReader.bufferSize);
    });

    this._delegate.updateViews(this.uri);
    await this._readBody(fileType);
  }

  // Load FSDB using node-addon-api
  private async loadFsdb() {
    // Lazy load the node-addon
    try {
      this.fsdbAddon = await require("../build/Release/fsdb_reader.node");
    } catch (error) {
      vscode.window.showErrorMessage("Failed to load FSDB reader, is LD_LIBRARY_PATH properly set? (" + error + ")");
      return;
    }

    await this.fsdbAddon.openFsdb(this.uri.fsPath);
    await vscode.window.withProgress({
      location: vscode.ProgressLocation.Notification,
      title: "Reading Scopes for " + this.uri.fsPath,
      cancellable: false
    }, async () => {
      await this.fsdbAddon.readScopes(this);
      await this.fsdbAddon.readMetadata(this);
    });
    this._delegate.updateViews(this.uri);
  }

  public readonly service: filehandler.Imports.Promisified = {

    log: (msg: string) => {console.log(msg);},
    fsread: (fd: number, offset: bigint, length: number): Uint8Array => {

      const bytesRead = this.fileReader.readSlice(fd, this.fileBuffer, 0, length, Number(offset));
      return this.fileBuffer.subarray(0, bytesRead);
    },
    getsize: (fd: number): bigint => {
      //const stats = fs.fstatSync(fd);
      return BigInt(this.fileReader.fileSize);
    },
    setscopetop: (name: string, id: number, tpe: string) => {

      const scope = createScope(name, tpe, "", id, -1);
      this.treeData.push(scope);
      this._netlistIdTable[id] = {netlistItem: scope, displayedItem: undefined, signalId: 0};
    },
    setvartop: (name: string, id: number, signalid: number, tpe: string, encoding: string, width: number, msb: number, lsb: number) => {

      const varItem = createVar(name, tpe, encoding, "", id, signalid, width, msb, lsb, this.isFsdb);
      this.treeData.push(varItem);
      this._netlistIdTable[id] = {netlistItem: varItem, displayedItem: undefined, signalId: signalid};
    },
    setmetadata: (scopecount: number, varcount: number, timescale: number, timeunit: string) => {
      this.setMetadata(scopecount, varcount, timescale, timeunit);
    },
    setchunksize: (chunksize: bigint, timeend: bigint) => {
      this.setChunkSize(chunksize, timeend);
    },
    sendtransitiondatachunk: (signalid: number, totalchunks: number, chunknum: number, min: number, max: number ,transitionData: string) => {

      this.webviewPanel?.webview.postMessage({
        command: 'update-waveform-chunk',
        signalId: signalid,
        transitionDataChunk: transitionData,
        totalChunks: totalchunks,
        chunkNum: chunknum,
        min: min,
        max: max
      });
    }
  };
  // The implementation of the log function that is called from WASM

  public get uri() { return this._uri; }
  public get netlistIdTable(): NetlistIdTable { return this._netlistIdTable; }
  public get webviewInitialized(): boolean { return this._webviewInitialized; }

  public async createWasmApi(wasmModule: WebAssembly.Module) {
    this.wasmApi = await filehandler._.bind(this.service, wasmModule, this._wasmWorker);
  }

  private async _readBody(fileType: string | undefined) {
    if (fileType === 'vcd') {
      vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: "Parsing Waveforms for " + this.uri.fsPath,
        cancellable: false
      }, async (progress) => {
        await this.wasmApi.readbody();
      });
    } else {
      await this.wasmApi.readbody();
    }
  }

  public onWebviewReady(webviewPanel: vscode.WebviewPanel) {
    //console.log("Webview Ready");
    this.webviewPanel = webviewPanel;
    if (this._webviewInitialized) {return;}
    if (!this.metadata.timeTableLoaded) {return;}
    //console.log("creating ruler");
    webviewPanel.webview.postMessage({
      command: 'create-ruler',
      waveformDataSet: this.metadata,
    });
    //console.log(this.metadata);
    this._webviewInitialized = true;
  }

  public onDoneParsingWaveforms() {
    //console.log("onDoneParsingWaveforms");
    if (this.webviewPanel) {
      this.onWebviewReady(this.webviewPanel);
    }
    //this.close(this.metadata.fd);
  }

  public setNetlistIdTable(netlistId: NetlistId, displayedSignalViewRef: NetlistItem | undefined) {
    const viewRef = this._netlistIdTable[netlistId];
    if (viewRef === undefined) {return;}
    viewRef.displayedItem = displayedSignalViewRef;
    this._netlistIdTable[netlistId] = viewRef;
  }

  public setMetadata(scopecount: number, varcount: number, timescale: number, timeunit: string) {
    this.metadata.moduleCount = scopecount; // scopecount might different between fsdb and vcd
    this.metadata.netlistIdCount = varcount; // varcount is not read for fsdb
    this.metadata.timeScale = timescale;
    this.metadata.timeUnit = timeunit;
    this._netlistIdTable = new Array(varcount);
  }

  public setChunkSize(chunksize: bigint, timeend: bigint) {
    this._setChunkSize(Number(chunksize));
    this.metadata.timeEnd = Number(timeend);
    this.metadata.chunkCount = Math.ceil(this.metadata.timeEnd / this.metadata.chunkTime);
    this.metadata.timeTableLoaded = true;
    this.onDoneParsingWaveforms();
  }

  private _setChunkSize(minTimeStemp: number) {
    // Prevent weird zoom ratios causing strange floating point math errors
    const newMinTimeStemp     = 10 ** (Math.round(Math.log10(minTimeStemp / 128)) | 0);
    const chunkTime           = newMinTimeStemp * 128;
    this.metadata.chunkTime   = chunkTime;
    this.metadata.defaultZoom = 512 / chunkTime;
  }

  public getSettings() {
    return {
      extensionVersion: vscode.extensions.getExtension('Lramseyer.vaporview')?.packageJSON.version,
      fileName: this.uri.fsPath,
      markerTime: this.webviewContext.markerTime,
      altMarkerTime: this.webviewContext.altMarkerTime,
      selectedSignal: this.getNameFromNetlistId(this.webviewContext.selectedSignal),
      zoomRatio: this.webviewContext.zoomRatio,
      scrollLeft: this.webviewContext.scrollLeft,
      displayedSignals: this.webviewContext.displayedSignals
    };
  }

  public formatTime(time: number) {
    const timeValue = time * this.metadata.timeScale;
    return timeValue.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",") + ' ' + this.metadata.timeUnit;
  }

  public async findTreeItem(modulePath: string, msb: number | undefined, lsb: number | undefined): Promise<NetlistItem | null> {
    const module = this.treeData.find((element) => element.label === modulePath.split('.')[0]);
    if (!module) {return null;}
    return await module.findChild(modulePath.split('.').slice(1).join('.'), this, msb, lsb);
  }

  public getNameFromNetlistId(netlistId: NetlistId | null) {
    if (netlistId === null) {return null;}
    const netlistData  = this.netlistIdTable[netlistId]?.netlistItem;
    const modulePath   = netlistData?.modulePath;
    const signalName   = netlistData?.name;
    const numberFormat = netlistData?.numberFormat;
    const msb          = netlistData?.msb;
    const lsb          = netlistData?.lsb;
    //const colorIndex   = netlistData?.colorIndex;
    return {
      name: modulePath + '.' + signalName,
      numberFormat: numberFormat,
      msb: msb,
      lsb: lsb,
    };
  }

  public async renderSignals(netlistIdList: NetlistId[]) {
    // Render the signal with the provided ID
    //console.log('renderSignals()');

    const signalList: any = [];
    if (!this.webviewPanel) {return;}

    netlistIdList.forEach((netlistId) => {
      const metadata  = this.netlistIdTable[netlistId]?.netlistItem;
      if (!metadata) {return;}

      signalList.push({
        signalId:    metadata.signalId,
        signalWidth: metadata.width,
        signalName:  metadata.name,
        modulePath:  metadata.modulePath,
        netlistId:   metadata.netlistId,
        type:        metadata.type,
        encoding:    metadata.encoding,
     });
    });
    this.webviewPanel.webview.postMessage({
      command: 'add-variable',
      signalList: signalList
    });
  }

  public revealSignalInWebview(netlistId: NetlistId) {
    // Render the signal with the provided ID
    if (!this.webviewPanel) {return;}

    this.webviewPanel.webview.postMessage({ 
      command: 'setSelectedSignal',
      netlistId: netlistId
    });
  }

  public removeSignalFromWebview(netlistId: NetlistId) {
    if (!this.webviewPanel) {return;}

    this.webviewPanel.webview.postMessage({ 
      command: 'remove-signal',
      netlistId: netlistId
   });
  }

  async getChildrenExternal(element: NetlistItem | undefined) {

    if (!element) {return Promise.resolve(this.treeData);} // Return the top-level netlist items
    if (this.isFsdb) {
      if (element.fsdbVarLoaded) {return Promise.resolve(element.children);}
      await this.fsdbAddon.readVars(element, this.netlistIdTable);
      element.fsdbVarLoaded = true;
      return Promise.resolve(element.children);
    }
    if (!this.wasmApi) {return Promise.resolve([]);}
    if (element.children.length > 0) {return Promise.resolve(element.children);}

    let modulePath = "";
    if (element.modulePath !== "") {modulePath += element.modulePath + ".";}
    modulePath += element.name;
    let itemsRemaining = Infinity;
    let startIndex     = 0;
    const result: NetlistItem[] = [];

    //console.log(element);
    let callLimit = 255;
    const varTable: any = {};
    while (itemsRemaining > 0) {
      //console.log("calling getscopes for " + modulePath + " with start index " + startIndex);
      const children = await this.wasmApi.getchildren(element.netlistId, startIndex);
      const childItems = JSON.parse(children);
      //console.log(children);
      //console.log(childItems);
      itemsRemaining = childItems.remainingItems;
      startIndex    += childItems.totalReturned;

      childItems.scopes.forEach((child: any) => {
        result.push(createScope(child.name, child.type, modulePath, child.id, -1));
      });
      childItems.vars.forEach((child: any) => {
        // Need to handle the case where we get a variable with the same name but
        // different bit ranges.
        const encoding = child.encoding.split('(')[0];
        const varItem = createVar(child.name, child.type, encoding, modulePath, child.netlistId, child.signalId, child.width, child.msb, child.lsb, false /*isFsdb*/);
        if (varTable[child.name] === undefined) {
          varTable[child.name] = [varItem];
        } else {
          varTable[child.name].push(varItem);
        }
        this.netlistIdTable[child.netlistId] = {netlistItem: varItem, displayedItem: undefined, signalId: child.signalId};
      });

      callLimit--;
      if (callLimit <= 0) {break;}
    }

    for (const [key, value] of Object.entries(varTable)) {
      if ((value as NetlistItem[]).length === 1) {
        result.push((value as NetlistItem[])[0]);
      } else {
        const varList = value as NetlistItem[];
        const bitList: NetlistItem[] = [];
        const busList: NetlistItem[] = [];
        let maxWidth = 0;
        let parent: any = undefined; // set to any because the linter is complaining
        varList.forEach((varItem) => {
          if (varItem.width === 1) {bitList.push(varItem);}
          else {busList.push(varItem);}
        });
        busList.forEach((busItem: NetlistItem) => {
          if (busItem.width > maxWidth) {
            maxWidth = busItem.width;
            parent = busItem;
          }
          result.push(busItem);
        });
        if (parent !== undefined) {
          parent.children = bitList;
          //parent.collapsibleState = vscode.TreeItemCollapsibleState.Collapsed;
        } else {
          result.push(...bitList);
        }

      }
    }

    element.children = result;
    return Promise.resolve(element.children);
  }

  public async getSignalDataFsdb(signalIdList: SignalId[]) {
    await vscode.window.withProgress({
      location: vscode.ProgressLocation.Notification,
      title: "Loading signals",
      cancellable: false
    }, async () => {
      await this.fsdbAddon.loadSignals(signalIdList);
    });

    signalIdList.forEach(async (signalId) => {
      const result = await this.fsdbAddon.getValueChanges(signalId);
      this.webviewPanel?.webview.postMessage({
        command: 'update-waveform-fsdb',
        signalId: signalId,
        transitionData: result.valueChanges,
        min: result.min,
        max: result.max
      });
      this.fsdbAddon.unloadSignal(signalId);
    });
  }

  public async unload() {
    //console.log("Reloading document");
    this.treeData         = [];
    this.displayedSignals = [];
    this._netlistIdTable  = [];
    if (this.isFsdb) {
      // TODO(heyfey): Bug: displayed signals not reset on reload
      await this.fsdbAddon.unload();
      this.fsdbAddon = null;
      this.isFsdb = false;
      this.fsdbTopModuleCount = 0;
    } else {
      this.fileReader.close(this.fileReader.fd);
      await this.wasmApi.unload();
    }
    this.metadata.timeTableLoaded = false;
    this._webviewInitialized = false;
    //console.log("Unloading webview");
    this.webviewPanel?.webview.postMessage({command: 'unload'});
  }

  public async reload() {
    await this.unload();
    await this.load();
  }

  //private readonly _onDidDispose = this._register(new vscode.EventEmitter<void>());
  /**
   * Fired when the document is disposed of.
   */
  //public readonly onDidDispose = this._onDidDispose.event;

  /**
   * Called by VS Code when there are no more references to the document.
   * This happens when all editors for it have been closed.
   */
  dispose(): void {
    this.unload();
    this._wasmWorker.terminate();
    this._delegate.updateViews(this.uri);
    this._delegate.removeFromCollection(this.uri, this);
  }

  /**
   * Called by fsdbAddon when traversing a scope.
   * fsdbScopeCallback and fsdbUpscopeCallback work as a pair and operate treeData as a stack.
   */
  fsdbScopeCallback(name: string, type: string, path: string, netlistId: number, scopeOffsetIdx: number) {
    this.treeData.push(createScope(name, type, path, netlistId, scopeOffsetIdx));
  }

  /**
   * Called by fsdbAddon when finished traversing a scope. Must be paired with a fsdbScopeCallback.
   */
  fsdbUpscopeCallback() {
    // Operate treeData as a stack
    const scope = this.treeData.pop()!;
    if (this.treeData.length === this.fsdbTopModuleCount) {
      // Is top level module
      this.treeData.push(scope);
      this.fsdbTopModuleCount++;
    } else {
      this.treeData[this.treeData.length - 1].children.push(scope);
    }
  }
}

// #region WebviewCollection
/**
 * Tracks all webviews.
 */
export class WebviewCollection {

  private numWebviews = 0;
  public get getNumWebviews() {return this.numWebviews;}

  private readonly _webviews = new Set<{
    readonly resource: string;
    readonly webviewPanel: vscode.WebviewPanel;
  }>();

  /**
   * Get all known webviews for a given uri.
   */
  public *get(uri: vscode.Uri): Iterable<vscode.WebviewPanel> {
    const key = uri.toString();
    for (const entry of this._webviews) {
      if (entry.resource === key) {
        yield entry.webviewPanel;
      }
    }
  }

  /**
   * Add a new webview to the collection.
   */
  public add(uri: vscode.Uri, webviewPanel: vscode.WebviewPanel) {
    const entry = { resource: uri.toString(), webviewPanel };
    this._webviews.add(entry);
    this.numWebviews++;

    webviewPanel.onDidDispose(() => {
      this._webviews.delete(entry);
      this.numWebviews--;
    });
  }
}

// #region NetlistTreeDataProvider
export class NetlistTreeDataProvider implements vscode.TreeDataProvider<NetlistItem> {

  private treeData: NetlistItem[] = [];
  private _onDidChangeTreeData: vscode.EventEmitter<NetlistItem | undefined> = new vscode.EventEmitter<NetlistItem | undefined>();
  readonly onDidChangeTreeData: vscode.Event<NetlistItem | undefined> = this._onDidChangeTreeData.event;
  private document: VaporviewDocument | undefined;

  public setCheckboxState(netlistItem: NetlistItem, checkboxState: vscode.TreeItemCheckboxState) {
    netlistItem.checkboxState = checkboxState;
    this._onDidChangeTreeData.fire(undefined); // Trigger a refresh of the Netlist view
  }

  public loadDocument(document: VaporviewDocument) {
    this.setTreeData(document.treeData);
    this.document = document;
  }

  // Method to set the tree data
  public setTreeData(netlistItems: NetlistItem[]) {
    this.treeData = netlistItems;
    this._onDidChangeTreeData.fire(undefined); // Trigger a refresh of the Netlist view
  }

  public hide() {
    this.setTreeData([]);
    this.document = undefined;
  }

  public getTreeData(): NetlistItem[] {return this.treeData;}
  getTreeItem(element:  NetlistItem): vscode.TreeItem {return element;}
  getChildren(element?: NetlistItem): Thenable<NetlistItem[]> {
    return this.document?.getChildrenExternal(element) ?? Promise.resolve([]);
  }

  getParent(element: NetlistItem): vscode.ProviderResult<NetlistItem> {
    if (this.document && element.modulePath !== "") {
      return Promise.resolve(this.document.findTreeItem(element.modulePath, undefined, undefined));
    }
    return null;
  }

  refresh(): void {
    this._onDidChangeTreeData.fire(undefined);
  }

}

export class DisplayedSignalsViewProvider implements vscode.TreeDataProvider<NetlistItem> {
  private treeData: NetlistItem[] = [];
  private _onDidChangeTreeData: vscode.EventEmitter<NetlistItem | undefined> = new vscode.EventEmitter<NetlistItem | undefined>();
  readonly onDidChangeTreeData: vscode.Event<NetlistItem | undefined> = this._onDidChangeTreeData.event;

  // Method to set the tree data
  public setTreeData(netlistItems: NetlistItem[]) {
    this.treeData = netlistItems;
    this._onDidChangeTreeData.fire(undefined); // Trigger a refresh of the Netlist view
  }

  public hide() {
    this.setTreeData([]);
  }

  public getTreeData(): NetlistItem[] {return this.treeData;}

  getTreeItem(element:  NetlistItem): vscode.TreeItem {return element;}
  getChildren(element?: NetlistItem): Thenable<NetlistItem[]> {
    if (element) {return Promise.resolve(element.children);} // Return the children of the selected element
    else         {return Promise.resolve(this.treeData);} // Return the top-level netlist items
  }

  public addSignalToTreeData(netlistItem: NetlistItem): NetlistItem {
    const n = netlistItem;
    const displayedItem = new NetlistItem(n.label, n.type, n.encoding, n.width, n.signalId, n.netlistId, n.name, n.modulePath, n.msb, n.lsb, -1, n.children, vscode.TreeItemCollapsibleState.None, n.checkboxState);
    displayedItem.iconPath = n.iconPath;
    this.treeData.push(displayedItem);
    this._onDidChangeTreeData.fire(undefined); // Trigger a refresh of the Netlist view
    return displayedItem;
  }

  public removeSignalFromTreeData(netlistItem: NetlistItem) {
    const index = this.treeData.indexOf(netlistItem);
    if (index > -1) {
      this.treeData.splice(index, 1);
    }
    this._onDidChangeTreeData.fire(undefined); // Trigger a refresh of the Netlist view
  }

  public getParent(element: NetlistItem): vscode.ProviderResult<NetlistItem> {
    return null;
  }

  refresh(): void {
    this._onDidChangeTreeData.fire(undefined);
  }
}

interface TreeCheckboxChangeEvent<T> {
  item: T;
  checked: boolean;
}

// #region NetlistItem
export class NetlistItem extends vscode.TreeItem {
  private _onDidChangeCheckboxState: vscode.EventEmitter<vscode.TreeItem | undefined | null> = new vscode.EventEmitter<vscode.TreeItem | undefined | null>();
  onDidChangeCheckboxState: vscode.Event<vscode.TreeItem | undefined | null> = this._onDidChangeCheckboxState.event;

  public numberFormat: string;
  public fsdbVarLoaded: boolean = false; // Only used in fsdb

  constructor(
    public readonly label:      string,
    public readonly type:       string,
    public readonly encoding:   string,
    public readonly width:      number,
    public readonly signalId:   SignalId, // Signal-specific information
    public readonly netlistId:  NetlistId, // Netlist-specific information
    public readonly name:       string,
    public readonly modulePath: string,
    public readonly msb:        number,
    public readonly lsb:        number,
    public readonly scopeOffsetIdx: number, // Only used in fsdb
    public children:         NetlistItem[] = [],
    public collapsibleState: vscode.TreeItemCollapsibleState,
    public checkboxState:    vscode.TreeItemCheckboxState | undefined = undefined // Display preference
  ) {
    super(label, collapsibleState);
    this.numberFormat = "hexadecimal";
    if (collapsibleState === vscode.TreeItemCollapsibleState.None) {
      this.contextValue = 'netlistVar'; // Set a context value for leaf nodes
    } else {
      this.contextValue = 'netlistScope'; // Set a context value for parent nodes
    }
  }

  // Method to recursively find a child element in the tree
  async findChild(label: string, document: VaporviewDocument, msb: number | undefined, lsb: number | undefined): Promise<NetlistItem | null> {

    // If the label is empty, return the current item, but try to find the child with the specified msb and lsb
    if (label === '') {
      if (this.children.length === 0 || this.children === undefined) {return this;}
      if (msb === undefined || lsb === undefined) {return this;}
      if (this.msb === msb && this.lsb === lsb) {return this;}

      const returnItem = this.children.find(childItem => childItem.msb === msb && childItem.lsb === lsb);
      if (returnItem) {return returnItem;}
      return this;
    }

    const subModules    = label.split(".");
    const currentModule = subModules.shift();
    if (this.children.length === 0) {
      await document.getChildrenExternal(this);
    }

    const childItem     = this.children.find((child) => child.name === currentModule);


    if (childItem) {
      return await childItem.findChild(subModules.join("."), document, msb, lsb);
    } else {
      return null;
    }
  }

  handleCommand() {
    //console.log("handleCommand()");
    //console.log(this);
  }

  // Method to toggle the checkbox state
  toggleCheckboxState() {
    this.checkboxState = this.checkboxState === vscode.TreeItemCheckboxState.Checked
      ? vscode.TreeItemCheckboxState.Unchecked
      : vscode.TreeItemCheckboxState.Checked;
    this._onDidChangeCheckboxState.fire(this);
  }

  /**
   * Called by fsdbAddon when traversing a var.
   */
  fsdbVarCallback(netlistIdTable: NetlistIdTable, name: string, type: string, encoding: string, path: string, netlistId: NetlistId, signalId: SignalId, width: number, msb: number, lsb: number) {
    const varItem = createVar(name, type, encoding, path, netlistId, signalId, width, msb, lsb, true /*isFsdb*/);
    this.children.push(varItem);

    // netlistIdTable is actually document.netlistIdTable object, which is passed to
    // fsdbAddon in getChildrenExternal, then later passed to this function from fsdbAddon
    netlistIdTable[varItem.netlistId] = { netlistItem: varItem, displayedItem: undefined, signalId: varItem.signalId };
  }

  fsdbArrayBeginCallback(name: string, path: string, netlistId: number) {
    this.children.push(createScope(name, "vhdlarray", path, netlistId, -1));
  }

  fsdbArrayEndCallback(size: number) {
    const arrayElements = [];
    for (let i = 0; i < size; i++) {
      const element = this.children.pop()!;
      arrayElements.push(element);
    }
    // const array = this.children[this.children.length - 1];
    const array = this.children.pop()!; // The last item would be the scope item for the array
    array.children.push(...arrayElements.reverse());
    array.fsdbVarLoaded = true;
    this.children.unshift(array); // Move to front to align with wellen
  }
}

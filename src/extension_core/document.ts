import * as vscode from 'vscode';
import { promisify } from 'util';
import { Worker } from 'worker_threads';
import { NetlistLinkProvider } from './terminal_links';
import { ChildProcess, fork } from 'child_process';
import * as path from 'path';
import * as fs from 'fs';

import { SignalId, NetlistId, VaporviewDocumentDelegate, scaleFromUnits, logScaleFromUnits} from './viewer_provider';
// Import the code generated by wit2ts
// If this file is not present, run `npm run generate:model` to generate it
// See GETTING_STARTED.md for more details
import { filehandler } from './filehandler';
import { NetlistItem, createScope, createVar, getInstancePath } from './tree_view';
import { json } from 'stream/consumers';
import { sign } from 'crypto';

export type NetlistIdTable = NetlistItem[];

type WaveformTopMetadata = {
  timeTableLoaded: boolean;
  moduleCount: number;
  netlistIdCount: number;
  signalIdCount: number;
  timeTableCount: number;
  timeEnd:     number;
  defaultZoom: number;
  timeScale:   number;
  timeUnit:    string;
};

interface fsWrapper {
  type: 'nodeFs' | 'workspace';
  loadStatic: boolean;
  fd: number;
  fileSize: number;
  bufferSize: number;
  fileData?: Uint8Array;
  loadFile: (uri: vscode.Uri, fileType: string) => void;
  readSlice: (fd: number, buffer: Uint8Array, offset: number, length: number, position: number) => number;
  close: (fd: number) => void;
}

export type SignalQueueEntry = {
  type: 'signal',
  id: SignalId
}

export type EnumQueueEntry = {
  type: 'enum',
  name: string,
  netlistId: NetlistId
}

export type QueueEntry = SignalQueueEntry | EnumQueueEntry;

type FsdbWorkerMessage = {
  id: string;
  result: any;
}

type FsdbWaveformData = {
  valueChanges: [number, string][];
  min: number;
  max: number;
}

const nodeFsWrapper: fsWrapper = {
  type: 'nodeFs',
  loadStatic: false,
  fd: 0,
  fileSize: 0,
  bufferSize: 60 * 1024,
  loadFile: async (uri: vscode.Uri, fileType: string) => {
    const open                 = promisify(fs.open);
    const stats                = fs.statSync(uri.fsPath);
    nodeFsWrapper.fd           = await open(uri.fsPath, 'r');
    nodeFsWrapper.fileSize     = stats.size;
    const fstMaxStaticLoadSize = vscode.workspace.getConfiguration('vaporview').get('fstMaxStaticLoadSize');
    const maxStaticSize        = Number(fstMaxStaticLoadSize) * 1048576;
    nodeFsWrapper.loadStatic   = (stats.size < maxStaticSize);

    // For VCD files, we stream the file, so we want to use a larger buffer size
    // For FST files, we want to use Rust's default buffer size of 8192 bytes,
    // but we don't care about buffer size if we statically load the file
    if (fileType === 'fst' && nodeFsWrapper.loadStatic === false) {
      nodeFsWrapper.bufferSize = 8192;
    }
  },
  readSlice: fs.readSync,
  close: promisify(fs.close)
};

const wroskpaceFsWrapper: fsWrapper = {
  type: "workspace",
  loadStatic: true,
  fd: 0,
  fileSize: 0,
  bufferSize: 60 * 1024,
  loadFile: async (uri: vscode.Uri, fileType: string) => {
    const stats                 = await vscode.workspace.fs.stat(uri);
    wroskpaceFsWrapper.fileData = await vscode.workspace.fs.readFile(uri);
    wroskpaceFsWrapper.fileSize = stats.size;
  },
  readSlice: (fd: number, buffer: Uint8Array, offset: number, length: number, position: number) => {
    buffer.set(wroskpaceFsWrapper.fileData!.subarray(position, position + length), offset);
    return length;
  },
  close: (fd: number) => {}
};

// Adapted from the VScode hex editor extension source
const getFsWrapper = async (uri: vscode.Uri): Promise<fsWrapper> => {

  if (uri.scheme === "file") {
    try {
      const fileStats = await fs.promises.stat(uri.fsPath);

      if (fileStats.isFile()) {
        return nodeFsWrapper;
      }
    } catch { /* probably not node.js, or file does not exist */  }
  }

  return wroskpaceFsWrapper;
};

// #region VaporviewDocument
export abstract class VaporviewDocument extends vscode.Disposable implements vscode.CustomDocument {

  protected disposables: vscode.Disposable[] = [];
  private readonly _uri: vscode.Uri;
  private readonly _fileType: string = 'unknown';
  private fileWatcher: vscode.FileSystemWatcher | undefined = undefined;
  private reloadDebounce: NodeJS.Timeout | undefined = undefined;
  private _fileUpdated: boolean = false;
  private _reloadPending: boolean = false;
  // Hierarchy
  public treeData:         NetlistItem[] = [];
  public displayedSignals: NetlistItem[] = [];
  protected _netlistIdTable: NetlistIdTable = [];
  private sortNetlist: boolean = vscode.workspace.getConfiguration('vaporview').get('sortNetlist') || false;
  public parametersLoaded: boolean = false;
  protected readonly _delegate: VaporviewDocumentDelegate;
  // Webview
  public webviewPanel: vscode.WebviewPanel | undefined = undefined;
  private _webviewInitialized: boolean = false;
  public metadata:   WaveformTopMetadata = {
    timeTableLoaded: false,
    moduleCount:    0,
    netlistIdCount: 0,
    signalIdCount:  0,
    timeTableCount: 0,
    timeEnd:     0,
    defaultZoom: 1,
    timeScale:   1,
    timeUnit:    "ns",
  };
  public webviewContext = {
    markerTime: null,
    altMarkerTime: null,
    selectedSignal: null,
    displayedSignals: [],
    zoomRatio: 1,
    scrollLeft: 0,
    numberFormat: "hexadecimal",
    autoReload: false,
  };

  constructor(uri: vscode.Uri, delegate: VaporviewDocumentDelegate) {
    super(() => this.dispose());
    this._uri = uri;
    this._fileType = uri.fsPath.split('.').pop()?.toLocaleLowerCase() || '';
    this._delegate = delegate;
    this.setupFileWatcher();
  }

  public get uri() { return this._uri; }
  public get fileType() { return this._fileType; }
  public get netlistIdTable(): NetlistIdTable { return this._netlistIdTable; }
  public get webviewInitialized(): boolean { return this._webviewInitialized; }
  public get fileUpdated(): boolean { return this._fileUpdated; }
  public get reloadPending(): boolean { return this._reloadPending; }

  public onWebviewReady(webviewPanel: vscode.WebviewPanel) {
    //console.log("Webview Ready");
    this.webviewPanel = webviewPanel;
    if (this._webviewInitialized) {return;}
    if (!this.metadata.timeTableLoaded) {return;}
    //console.log("Initializing Viewport");
    webviewPanel.webview.postMessage({
      command: 'initViewport',
      metadata: this.metadata,
      uri: this.uri
    });
    this.setConfigurationSettings();
    //console.log(this.metadata);
    this._webviewInitialized = true;
  }

  public setConfigurationSettings() {
    const scrollingMode      = vscode.workspace.getConfiguration('vaporview').get('scrollingMode');
    const rulerLines         = vscode.workspace.getConfiguration('vaporview').get('showRulerLines');
    const fillMultiBitValues = vscode.workspace.getConfiguration('vaporview').get('fillMultiBitValues');
    this.webviewPanel?.webview.postMessage({
      command: 'setConfigSettings',
      scrollingMode: scrollingMode,
      rulerLines: rulerLines,
      fillMultiBitValues: fillMultiBitValues
    });
  }

  public onDoneParsingWaveforms() {
    //console.log("onDoneParsingWaveforms");
    if (this.webviewPanel) {
      this.onWebviewReady(this.webviewPanel);
    }
    //this.close(this.metadata.fd);
  }

  private setupFileWatcher() {
    if (this._uri.scheme !== 'file') { return; }

    const pattern = new vscode.RelativePattern(path.dirname(this._uri.fsPath), path.basename(this._uri.fsPath));
    const watcher = vscode.workspace.createFileSystemWatcher(pattern);
    const scheduleReload = () => {
      if (this.reloadDebounce) {clearTimeout(this.reloadDebounce);}
      this.reloadDebounce = setTimeout(() => this.handleUpdateFile(), 500);
      this._fileUpdated = true;
    };

    watcher.onDidChange(scheduleReload, this, this.disposables);
    this.disposables.push(watcher);
    this.fileWatcher = watcher;
  }

  private handleUpdateFile() {
    this._delegate.logOutputChannel("File changed: " + this._uri.fsPath);
    // We only want to reload the file if the webview is active
    if (this.webviewContext.autoReload && this._fileUpdated) {
      this._reloadPending = true;
      if (this.webviewPanel?.active) {
        vscode.commands.executeCommand('vaporview.reloadFile', this._uri);
      }
    }
  }

  public sortNetlistScopeChildren(netlistItems: NetlistItem[]) {

    let result = [];
    const scopes  = netlistItems.filter(item => item.contextValue === 'netlistScope');
    const variables = netlistItems.filter(item => item.contextValue !== 'netlistScope');
    const parameters = variables.filter(item => item.type === 'Parameter');
    const signals    = variables.filter(item => item.type !== 'Parameter');

    if (this.sortNetlist) {
      result.push(...(scopes.sort((a, b) => a.name.localeCompare(b.name))));
      result.push(...(parameters.sort((a, b) => a.name.localeCompare(b.name))));
      result.push(...(signals.sort((a, b) => a.name.localeCompare(b.name))));
    } else {
      result.push(...scopes);
      result.push(...parameters);
      result.push(...signals);
    }

    return result;
  }

  public setMetadata(scopecount: number, varcount: number, timescale: number, timeunit: string) {
    this.metadata.moduleCount      = scopecount; // scopecount might different between fsdb and vcd
    this.metadata.netlistIdCount   = varcount; // varcount is not read for fsdb
    this.metadata.timeScale        = timescale;
    this.metadata.timeUnit         = timeunit;
    this._netlistIdTable = new Array(varcount);
  }

  public setChunkSize(chunksize: bigint, timeend: bigint, timetablelength: bigint) {
    const newMinTimeStemp         = 10 ** (Math.round(Math.log10(Number(chunksize) / 128)) | 0);
    this.metadata.defaultZoom     = 4 / newMinTimeStemp;
    this.metadata.timeEnd         = Number(timeend);
    this.metadata.timeTableLoaded = true;
    this.metadata.timeTableCount   = Number(timetablelength);
    this._delegate.logOutputChannel("Total Value Change Events: " + this.toStringWithCommas(Number(timetablelength)));
    this.onDoneParsingWaveforms();
  }

  protected setTerminalLinkProvider() {
    const scopeTopNames = this.treeData.filter(item => item.contextValue === 'netlistScope').map((item) => item.name);
    const terminalLinkProvider = new NetlistLinkProvider(this._delegate, scopeTopNames);
    const disposable = vscode.window.registerTerminalLinkProvider(terminalLinkProvider);
    this.disposables.push(disposable);
  }

  public reveal() {
    if (!this.webviewPanel) {return;}
    this.webviewPanel.reveal(vscode.ViewColumn.Active);
  }

  public getSettings() {
    return {
      extensionVersion: vscode.extensions.getExtension('Lramseyer.vaporview')?.packageJSON.version,
      fileName: this.uri.fsPath,
      markerTime: this.webviewContext.markerTime,
      altMarkerTime: this.webviewContext.altMarkerTime,
      selectedSignal: this.getNameFromNetlistId(this.webviewContext.selectedSignal),
      zoomRatio: this.webviewContext.zoomRatio,
      scrollLeft: this.webviewContext.scrollLeft,
      displayedSignals: this.webviewContext.displayedSignals
    };
  }

  public toStringWithCommas(n: number) {return n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");}

  public formatTime(time: number, unit: string) {
    const timescaleOffset = logScaleFromUnits(this.metadata.timeUnit) - logScaleFromUnits(unit);
    const timeScaleOffsetInverse = logScaleFromUnits(unit) - logScaleFromUnits(this.metadata.timeUnit);
    let timeValue;
    if (timescaleOffset > 0) {
      timeValue = time * this.metadata.timeScale * (10 ** timescaleOffset);
    } else {
      timeValue = time * this.metadata.timeScale / (10 ** timeScaleOffsetInverse);
    }
    const strings = timeValue.toString().split('.');
    strings[0] = strings[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    return strings.join('.') + ' ' + unit;
  }

  public async findTreeItem(scopePath: string, msb: number | undefined, lsb: number | undefined): Promise<NetlistItem | null> {
    //console.log("findTreeItem() " + scopePath + " msb: " + msb + " lsb: " + lsb);
    if (!scopePath || scopePath === '') {return null;}
    const module = this.treeData.find((element) => element.label === scopePath.split('.')[0]);
    if (!module) {return null;}
    return await module.findChild(scopePath.split('.').slice(1).join('.'), this, msb, lsb);
  }

  public getNameFromNetlistId(netlistId: NetlistId | null) {
    if (netlistId === null) {return null;}
    const netlistData  = this.netlistIdTable[netlistId];
    const scopePath    = netlistData?.scopePath;
    const signalName   = netlistData?.name;
    const numberFormat = netlistData?.numberFormat;
    const msb          = netlistData?.msb;
    const lsb          = netlistData?.lsb;
    //const colorIndex   = netlistData?.colorIndex;
    return {
      name: scopePath + '.' + signalName,
      numberFormat: numberFormat,
      msb: msb,
      lsb: lsb,
    };
  }

  public async renderSignals(netlistIdList: NetlistId[], moveToGroup: string[] | undefined, index: number | undefined) {
    // Render the signal with the provided ID
    //console.log('renderSignals()');

    const signalList: any = [];
    if (!this.webviewPanel) {return;}

    netlistIdList.forEach((netlistId) => {
      const metadata  = this.netlistIdTable[netlistId];
      if (!metadata) {return;}

      signalList.push({
        signalId:    metadata.signalId,
        signalWidth: metadata.width,
        signalName:  metadata.name,
        scopePath:   metadata.scopePath,
        netlistId:   metadata.netlistId,
        type:        metadata.type,
        encoding:    metadata.encoding,
        enumType:    metadata.enumType,
     });

      this._delegate.emitEvent({
        eventType: 'addVariable',
        uri: this.uri,
        instancePath: getInstancePath(metadata),
        netlistId: metadata.netlistId,
      })
    });
    this.webviewPanel.webview.postMessage({
      command: 'add-variable',
      signalList: signalList,
      groupPath: moveToGroup,
      index: index
    });
  }

  public fetchData(requestList: QueueEntry[]) {
    const signalIdList: SignalId[] = [];
    const enumList: EnumQueueEntry[] = [];
    requestList.forEach((entry) => {
      if (entry.type === 'signal') {
        signalIdList.push(entry.id);
      } else if (entry.type === 'enum') {
        enumList.push(entry);
      }
    });
    if (enumList.length > 0) {
      this.getEnumData(enumList);
    }
    if (signalIdList.length === 0) {return;}
    this.getSignalData(signalIdList);
  }

  public revealSignalInWebview(netlistId: NetlistId) {
    // Render the signal with the provided ID
    if (!this.webviewPanel) {return;}

    this.webviewPanel.webview.postMessage({
      command: 'setSelectedSignal',
      netlistId: netlistId
    });
  }

  public removeSignalFromWebview(netlistId: NetlistId | undefined, rowId: number | undefined, removeAllSelected: boolean) {
    if (!this.webviewPanel) {return;}

    this.webviewPanel.webview.postMessage({
      command: 'remove-signal',
      netlistId: netlistId,
      rowId: rowId,
      removeAllSelected: removeAllSelected
   });

    //const metadata = this.netlistIdTable[netlistId];
    //this._delegate.emitEvent({
    //  eventType: 'removeVariable',
    //  uri: this.uri,
    //  instancePath: getInstancePath(metadata),
    //  netlistId: metadata.netlistId
    //})
  }

  public async unloadTreeData() {
    this.treeData         = [];
    this.displayedSignals = [];
    this._netlistIdTable  = [];
  }

  public async unloadWebview() {
    this._webviewInitialized = false;
    if (!this.webviewPanel) {return;}
    try {
      this.webviewPanel?.webview.postMessage({command: 'unload'});
    } catch (e) {
      // This can happen if the webview has already been disposed of
    }
  }

  public async reload() {
    this.sortNetlist = vscode.workspace.getConfiguration('vaporview').get('sortNetlist') || false;
    this.parametersLoaded = false;
    await this.unload();
    await this.load();
    this._fileUpdated = false;
    this._reloadPending = false;
  }

  public abstract getChildrenExternal(element: NetlistItem | undefined): Promise<NetlistItem[]>;
  public abstract getSignalData(signalIdList: SignalId[]): Promise<void>;
  public abstract getEnumData(enumNameList: EnumQueueEntry[]): Promise<void>;
  public abstract getValuesAtTime(e: any): Promise<any>;
  protected abstract load(): Promise<void>;
  public abstract unload(): Promise<void>;
  public abstract dispose(): void;

  //private readonly _onDidDispose = this._register(new vscode.EventEmitter<void>());
  /**
   * Fired when the document is disposed of.
   */
  //public readonly onDidDispose = this._onDidDispose.event;

}

// #region VaporviewDocumentWasm
export class VaporviewDocumentWasm extends VaporviewDocument implements vscode.CustomDocument {
  private fileReader: fsWrapper;
  // Wasm
  public _wasmWorker: Worker;
  public wasmApi: any;
  private fileBuffer: Uint8Array;

  static async create(
    uri: vscode.Uri,
    backupId: string | undefined,
    wasmWorker: Worker,
    wasmModule: WebAssembly.Module,
    delegate: VaporviewDocumentDelegate,
  ): Promise<VaporviewDocumentWasm | PromiseLike<VaporviewDocumentWasm>> {

    const fsWrapper = await getFsWrapper(uri);
    const document  = new VaporviewDocumentWasm(uri, fsWrapper, wasmWorker, delegate);
    await document.createWasmApi(wasmModule);
    document.load();
    return document;
  }

  constructor(
    uri: vscode.Uri,
    fileReader: fsWrapper,
    _wasmWorker: Worker,
    delegate: VaporviewDocumentDelegate,
  ) {
    super(uri, delegate);
    this._wasmWorker = _wasmWorker;
    this.fileBuffer  = new Uint8Array(65536);
    this.fileReader = fileReader;
  }

  // Load VCD, FST, GHW files using WASM
  protected async load() {

    const fileType = this.uri.fsPath.split('.').pop()?.toLocaleLowerCase() || '';
    this._delegate.logOutputChannel("Using " + this.fileReader.type + " - Loading " + fileType + " file: " + this.uri.fsPath);
    const loadTime = Date.now();
    await this.fileReader.loadFile(this.uri, fileType);

    if (fileType === 'fst' && this.fileReader.loadStatic === false) {
      const fstMaxStaticLoadSize = vscode.workspace.getConfiguration('vaporview').get('fstMaxStaticLoadSize');
      this._delegate.logOutputChannel(
        this.uri.fsPath + ' is larger than the max static load size of ' + fstMaxStaticLoadSize +
        ' MB. File will be loaded dynamically. Configure max load size in the settings menu');
    }

    await vscode.window.withProgress({
      location: vscode.ProgressLocation.Notification,
      title: "Parsing Netlist for " + this.uri.fsPath,
      cancellable: false
    }, async () => {
      await this.wasmApi.loadfile(BigInt(this.fileReader.fileSize), this.fileReader.fd, this.fileReader.loadStatic, this.fileReader.bufferSize);
    });

    const netlistFinishTime = Date.now();
    const netlistTime = (netlistFinishTime - loadTime) / 1000;
    this._delegate.logOutputChannel("Finished parsing netlist for " + this.uri.fsPath);
    this._delegate.logOutputChannel(
      "Scope count: " + this.metadata.moduleCount + 
      ", Variable count: " + this.metadata.netlistIdCount + 
      ", Time: " + netlistTime + " seconds");

    this._delegate.updateViews(this.uri);
    await this._readBody(fileType);
    
    this._delegate.logOutputChannel("Finished parsing waveforms for " + this.uri.fsPath);
    this._delegate.logOutputChannel("Time: " + (Date.now() - netlistFinishTime) / 1000 + " seconds");

    this.setTerminalLinkProvider();
    if (fileType !== 'fst') {
      this.getTopLevelParameters();
    }
  }

  public readonly service: filehandler.Imports.Promisified = {

    log: (msg: string) => {console.log(msg);},
    outputlog: (msg: string) => {this._delegate.logOutputChannel(msg);},
    fsread: (fd: number, offset: bigint, length: number): Uint8Array => {
      //console.log(`fsread called with fd=${fd}, offset=${offset}, length=${length}`);
      const bytesRead = this.fileReader.readSlice(fd, this.fileBuffer, 0, length, Number(offset));
      return this.fileBuffer.subarray(0, bytesRead);
    },
    getsize: (fd: number): bigint => {
      //const stats = fs.fstatSync(fd);
      return BigInt(this.fileReader.fileSize);
    },
    setscopetop: (name: string, id: number, tpe: string) => {

      const scope = createScope(name, tpe, "", id, -1, this.uri);
      this.treeData.push(scope);
      this._netlistIdTable[id] = scope;
    },
    setvartop: (name: string, id: number, signalid: number, tpe: string, encoding: string, width: number, msb: number, lsb: number, enumtype: string) => {

      const varItem = createVar(name, "", tpe, encoding, "", id, signalid, width, msb, lsb, enumtype, false /*isFsdb*/, this.uri);
      this.treeData.push(varItem);
      this._netlistIdTable[id] = varItem;
    },
    setmetadata: (scopecount: number, varcount: number, timescale: number, timeunit: string) => {
      this.setMetadata(scopecount, varcount, timescale, timeunit);
    },
    setchunksize: (chunksize: bigint, timeend: bigint, timetablelength: bigint) => {
      this.setChunkSize(chunksize, timeend, timetablelength);
    },
    sendtransitiondatachunk: (signalid: number, totalchunks: number, chunknum: number, min: number, max: number ,transitionData: string) => {

      this.webviewPanel?.webview.postMessage({
        command: 'update-waveform-chunk',
        signalId: signalid,
        transitionDataChunk: transitionData,
        totalChunks: totalchunks,
        chunkNum: chunknum,
        min: min,
        max: max
      });
    },
    sendenumdata: (name: string, totalchunks: number, chunknum: number, data: string) => {
      this.webviewPanel?.webview.postMessage({
        command: 'update-enum-chunk',
        enumName: name,
        enumDataChunk: data,
        totalChunks: totalchunks,
        chunkNum: chunknum,
      });
    },
    sendcompressedtransitiondata: (signalid: number, signalwidth: number, totalchunks: number, chunknum: number, min: number, max: number, compresseddata: Uint8Array, originalsize: number) => {

      this.webviewPanel?.webview.postMessage({
        command: 'update-waveform-chunk-compressed',
        signalId: signalid,
        signalWidth: signalwidth,
        compressedDataChunk: Array.from(compresseddata), // Convert Uint8Array to regular array for JSON serialization
        totalChunks: totalchunks,
        chunkNum: chunknum,
        min: min,
        max: max,
        originalSize: originalsize
      });
    }
  };
  // The implementation of the log function that is called from WASM

  public async createWasmApi(wasmModule: WebAssembly.Module) {
    this.wasmApi = await filehandler._.bind(this.service, wasmModule, this._wasmWorker);
  }

  private async _readBody(fileType: string | undefined) {
    if (fileType === 'vcd') {
      vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: "Parsing Waveforms for " + this.uri.fsPath,
        cancellable: false
      }, async (progress) => {
        await this.wasmApi.readbody();
      });
    } else {
      await this.wasmApi.readbody();
    }
  }

  private getParametersInTreeData(treeData: NetlistItem[]) {
    let result: NetlistItem[] = [];
    treeData.forEach((item) => {
      if (item.type === 'Parameter') {
        result.push(item);
      }
      if (item.children.length > 0) {
        result.push(...this.getParametersInTreeData(item.children as NetlistItem[]));
      }
    });
    return result;
  }

  private async getTopLevelParameters() {
    if (this.parametersLoaded) {return;}
    if (!this.wasmApi) {return;}

    const parameterItems  = this.getParametersInTreeData(this.treeData);
    const signalIdList    = parameterItems.map((param) => param.signalId);
    const params          = await this.wasmApi.getparametervalues(signalIdList);
    const parameterValues = JSON.parse(params);
    parameterItems.forEach((param) => {
      const paramValue = parameterValues.find((entry: any) => entry[0] === param.signalId);
      if (paramValue) {
        param.setParamAndTooltip(paramValue[1]);
      }
    });
    // set tree data provider to refresh
    this._delegate.updateViews(this.uri);
    this.parametersLoaded = true;
  }

  async getChildrenExternal(element: NetlistItem | undefined) {

    if (!element) {return Promise.resolve(this.treeData);} // Return the top-level netlist items
    if (!this.wasmApi) {return Promise.resolve([]);}
    if (element.children.length > 0) {return Promise.resolve(element.children);}

    let scopePath = "";
    if (element.scopePath !== "") {scopePath += element.scopePath + ".";}
    scopePath += element.name;
    let itemsRemaining = Infinity;
    let startIndex     = 0;
    const result: NetlistItem[] = [];

    //console.log(element);
    let callLimit = 255;
    const varTable: any = {};
    while (itemsRemaining > 0) {
      //console.log("calling getscopes for " + scopePath + " with start index " + startIndex);
      const children = await this.wasmApi.getchildren(element.netlistId, startIndex);
      const childItems = JSON.parse(children);
      //console.log(children);
      //console.log(childItems);
      itemsRemaining = childItems.remainingItems;
      startIndex    += childItems.totalReturned;

      const scopes: NetlistItem[] = childItems.scopes?.map((child: any) => {
        return createScope(child.name, child.type, scopePath, child.id, -1, this.uri);
      }) || [];
      const vars:   NetlistItem[] = childItems.vars?.map((child: any) => {
        return createVar(child.name, child.paramValue, child.type, child.encoding.split('(')[0], scopePath, child.netlistId, child.signalId, child.width, child.msb, child.lsb, child.enumType, false /*isFsdb*/, this.uri);
      }) || [];

      //result.push(...(scopes.sort((a, b) => a.name.localeCompare(b.name))));
      result.push(...(scopes));
      
      //vars.sort((a, b) => a.name.localeCompare(b.name)).forEach((varItem) => { 
      vars.forEach((varItem) => { 
        // Need to handle the case where we get a variable with the same name but
        // different bit ranges.
        if (varTable[varItem.name] === undefined) {
          varTable[varItem.name] = [varItem];
        } else {
          varTable[varItem.name].push(varItem);
        }
        this.netlistIdTable[varItem.netlistId] = varItem;
      });

      callLimit--;
      if (callLimit <= 0) {break;}
    }

    for (const [key, value] of Object.entries(varTable)) {
      if ((value as NetlistItem[]).length === 1) {
        result.push((value as NetlistItem[])[0]);
      } else {
        const varList = value as NetlistItem[];
        const bitList: NetlistItem[] = [];
        const busList: NetlistItem[] = [];
        let maxWidth = 0;
        let parent: any = undefined; // set to any because the linter is complaining
        varList.forEach((varItem) => {
          if (varItem.width === 1) {bitList.push(varItem);}
          else {busList.push(varItem);}
        });
        busList.forEach((busItem: NetlistItem) => {
          if (busItem.width > maxWidth) {
            maxWidth = busItem.width;
            parent = busItem;
          }
          result.push(busItem);
        });
        if (parent !== undefined) {
          parent.children = bitList;
          parent.collapsibleState = vscode.TreeItemCollapsibleState.Collapsed;
        } else {
          result.push(...bitList);
        }

      }
    }

    element.children = this.sortNetlistScopeChildren(result);
    return Promise.resolve(element.children);
  }

  public async getValuesAtTime(e: any): Promise<any> {
    let time = e.time;
    if (!e.time) {
      time = this.webviewContext.markerTime;
    }
    const result = await this.wasmApi.getvaluesattime(BigInt(time), e.instancePaths.join(" "));
    return JSON.parse(result);
  }

  public async getSignalData(signalIdList: SignalId[]) {
    this.wasmApi.getsignaldata(signalIdList);
    this.getTopLevelParameters();
  }

  public async getEnumData(enumNameList: EnumQueueEntry[]) {
    const netlistIdList = enumNameList.map((entry) => entry.netlistId);
    this.wasmApi.getenumdata(netlistIdList);
  }

  public async unload() {
    //console.log("Reloading document");
    this.unloadWebview();
    this.unloadTreeData();

    this.fileReader.close(this.fileReader.fd);
    await this.wasmApi.unload();

    this.metadata.timeTableLoaded = false;
  }

  /**
  * Called by VS Code when there are no more references to the document.
  * This happens when all editors for it have been closed.
  */
  dispose(): void {
    this.unload();
    this._wasmWorker.terminate();
    this._delegate.updateViews(this.uri);
    this._delegate.removeFromCollection(this.uri, this);
    this.disposables.forEach((disposable) => {disposable.dispose();});
    this.disposables = [];
  }
}

// #region VaporviewDocumentFsdb
export class VaporviewDocumentFsdb extends VaporviewDocument implements vscode.CustomDocument {
  // Fsdb
  public fsdbWorker: ChildProcess | undefined = undefined;
  private fsdbTopModuleCount: number = 0;
  private fsdbCurrentScope: NetlistItem | undefined = undefined;

  static async create(
    uri: vscode.Uri,
    backupId: string | undefined,
    delegate: VaporviewDocumentDelegate,
  ): Promise<VaporviewDocumentFsdb | PromiseLike<VaporviewDocumentFsdb>> {

    const document = new VaporviewDocumentFsdb(uri, delegate);
    document.load();
    return document;
  }

  constructor(
    uri: vscode.Uri,
    delegate: VaporviewDocumentDelegate,
  ) {
    super(uri, delegate);
  }

  protected async load() {
    if (process.platform !== 'linux') {
      vscode.window.showErrorMessage("FSDB support is currently available on Linux only.");
      return;
    }
    // Create FSDB worker that loads FSDB using node-addon-api
    const fsdbReaderLibsPath = vscode.workspace.getConfiguration('vaporview').get('fsdbReaderLibsPath');
    this.fsdbWorker = fork(path.resolve(__dirname, 'fsdb_worker.js'), {
      env: {
        ...process.env,
        LD_LIBRARY_PATH: `${process.env.LD_LIBRARY_PATH ? process.env.LD_LIBRARY_PATH + ':' : ''}${fsdbReaderLibsPath}`
      }
    });
    this.fsdbWorker.setMaxListeners(50);
    this.setupFsdbWorkerListeners();

    await this.callFsdbWorkerTask({
      command: 'openFsdb',
      fsdbPath: this.uri.fsPath
    });

    await vscode.window.withProgress({
      location: vscode.ProgressLocation.Notification,
      title: "Reading Scopes for " + this.uri.fsPath,
      cancellable: false
    }, async () => {
      await this.callFsdbWorkerTask({
        command: 'readScopes'
      });
    });

    await vscode.window.withProgress({
      location: vscode.ProgressLocation.Notification,
      title: "Reading Metadata for " + this.uri.fsPath,
      cancellable: false
    }, async () => {
      await this.callFsdbWorkerTask({
        command: 'readMetadata'
      });
    });

    this._delegate.updateViews(this.uri);
  }

  private setupFsdbWorkerListeners(): void {
    if (!this.fsdbWorker) return;
    this.fsdbWorker.on('online', () => {
      console.log('FSDB worker is online.');
    });

    this.fsdbWorker.on('error', (err: Error) => {
      console.error('FSDB worker error:', err);
    });

    this.fsdbWorker.on('exit', (code: any, signal: any) => {
      if (code !== 0) {
        console.error(`Child process exited with error code ${code} (signal: ${signal})`);
      }
    });

    this.fsdbWorker.on('message', (msg: any) => {
      // console.log('Main thread received:', JSON.stringify(msg, null, 2));
      this.handleMessage(msg);
    });
  }

  private handleMessage(message: any) {
    switch (message.command) {
      case 'require-failed': {
        vscode.window.showErrorMessage("Failed to load FSDB reader, is vaporview.fsdbReaderLibsPath properly set? (" + message.error.code + ")");
        break;
      }
      case 'fsdb-scope-callback': { this.fsdbScopeCallback(message.name, message.type, message.path, message.netlistId, message.scopeOffsetIdx); break; }
      case 'fsdb-upscope-callback': { this.fsdbUpscopeCallback(); break; }
      case 'setMetadata': { this.setMetadata(message.scopecount, message.varcount, message.timescale, message.timeunit); break; }
      case 'setChunkSize': { this.setChunkSize(message.chunksize, message.timeend, BigInt(0)); break; }
      case 'fsdb-var-callback': {
        this.fsdbVarCallback(
          message.name, message.type, message.encoding, message.path, message.netlistId, message.signalId, message.width, message.msb, message.lsb);
        break;
      }
      case 'fsdb-array-begin-callback': { this.fsdbArrayBeginCallback(message.name, message.path, message.netlistId); break; }
      case 'fsdb-array-end-callback': { this.fsdbArrayEndCallback(message.size); break; }
    }
  }

  private callFsdbWorkerTask(message: any) {
    if (this.fsdbWorker === undefined) return Promise.resolve([]);
    return new Promise((resolve, reject) => {
      // try {
      //   console.log("callFsdbWorkerTask, message: " + JSON.stringify(message));
      // } catch (e) {
      //   console.error('Data is not serializable:', e);
      // }
      const id = Math.random().toString(36).substring(2, 9);
      message.id = id;

      const messageHandler = (message: any) => {
        if (message.id === id) {
          this.fsdbWorker!.off('message', messageHandler);
          if (message.error) {
            console.log(message.error);
            return reject(new Error(message.error));
          }
          resolve(message);
        }
      };

      this.fsdbWorker!.on('message', messageHandler);

      this.fsdbWorker!.send(message);
    });
  }

  private async fsdbReadVars(element: NetlistItem | undefined) {
    if (!element) return;
    // Only one scope is allowed to be reading vars at a time
    this.fsdbCurrentScope = element;

    let scopePath = "";
    if (element.scopePath !== "") {scopePath += element.scopePath + ".";}
    scopePath += element.name; // How about genblk?

    await this.callFsdbWorkerTask({
      command: 'readVars',
      scopePath: scopePath,
      scopeOffsetIdx: element.scopeOffsetIdx
    });
    // TODO(heyfey): Wait for all callbacks finish
  }

  async getChildrenExternal(element: NetlistItem | undefined) {

    if (!element) { return Promise.resolve(this.treeData); } // Return the top-level netlist items
    if (element.fsdbVarLoaded) { return Promise.resolve(element.children); }
    await this.fsdbReadVars(element);
    element.fsdbVarLoaded = true;
    return Promise.resolve(element.children);
  }

  public async getSignalData(signalIdList: SignalId[]) {
    await vscode.window.withProgress({
      location: vscode.ProgressLocation.Notification,
      title: "Loading signals",
      cancellable: false
    }, async () => {
      await this.callFsdbWorkerTask({
        command: 'loadSignals',
        signalIdList: signalIdList
      });
    });

    // Map each signalId to a promise for handling its task.
    const tasks = signalIdList.map(async (signalId) => {
      const result = await this.callFsdbWorkerTask({
        command: 'getValueChanges',
        signalId: signalId
      });
      const message = result as FsdbWorkerMessage;
      const data = message.result as FsdbWaveformData;

      // Since we're receiving the full set of value changes, we can hard code
      // the chunk number and total chunks
      this.webviewPanel?.webview.postMessage({
        command: 'update-waveform-chunk',
        signalId: signalId,
        transitionDataChunk: data.valueChanges,
        totalChunks: 1,
        chunkNum: 0,
        min: data.min,
        max: data.max
      });

      // this.callFsdbWorkerTask({
      //   command: 'unloadSignal',
      //   signalId: signalId
      // });
    });
    // Run all tasks concurrently and wait for them to complete.
    // await Promise.all(tasks);
  }

  public async getEnumData(enumNameList: EnumQueueEntry[]) {
    // Not Implemented for FSDB
    // TODO(heyfey): Implement fetching enum data for FSDB
    return;
  }

  public async getValuesAtTime(e: any): Promise<any> {
    let time = e.time;
    if (!e.time) {time = this.webviewContext.markerTime;}

    // No time provided nor marker time set, return empty array
    if (time === undefined || time === null) {
      return [];
    }

    const instancePath2signalId: Map<string, number> = new Map();
    const signalId2values: Map<number, any> = new Map();
    for (const instancePath of e.instancePaths) {
      const netlistItem = await this.findTreeItem(instancePath, undefined, undefined);
      if (netlistItem) {
        instancePath2signalId.set(instancePath, netlistItem.signalId);
        signalId2values.set(netlistItem.signalId, []);
      }
    }
    if (signalId2values.size === 0) {
      return [];
    }

    const signalIdList = Array.from(signalId2values.keys());
    await this.callFsdbWorkerTask({
      command: 'loadSignals',
      signalIdList: signalIdList
    });

    // call fsdbworker task for each signalId
    await Promise.all(signalIdList.map(async (signalId) => {
      const result = await this.callFsdbWorkerTask({
        command: 'getValuesAtTime',
        signalId: signalId,
        time: time
      });
      const message = result as FsdbWorkerMessage;
      // message.result is an array of values. e.g. ["0", "1", "x", "1", ...]
      signalId2values.set(signalId, message.result);
    }));

    // Convert the map to an array of objects
    const result = [];
    for (const [instancePath, signalId] of instancePath2signalId.entries()) {
      const values = signalId2values.get(signalId);
      if (values !== undefined) {
        result.push({
          instancePath: instancePath,
          value: values
        });
      }
    }
    return result;
  }

  public async unload() {
    //console.log("Reloading document");
    this.unloadTreeData();

    await this.callFsdbWorkerTask({ command: 'unload' });
    if (this.fsdbWorker !== undefined) {
      this.fsdbWorker.disconnect();
      this.fsdbWorker = undefined;
    }
    this.fsdbTopModuleCount = 0;
    this.fsdbCurrentScope = undefined;

    this.metadata.timeTableLoaded = false;
    this.unloadWebview();
  }

  /**
  * Called by VS Code when there are no more references to the document.
  * This happens when all editors for it have been closed.
  */
  dispose(): void {
    this.unload();
    this._delegate.updateViews(this.uri);
    this._delegate.removeFromCollection(this.uri, this);
    this.disposables.forEach((disposable) => {disposable.dispose();});
    this.disposables = [];
  }

  /**
   * Called by fsdbWorker when traversing a scope.
   * fsdbScopeCallback and fsdbUpscopeCallback work as a pair and operate treeData as a stack.
   */
  fsdbScopeCallback(name: string, type: string, path: string, netlistId: number, scopeOffsetIdx: number) {
    this.treeData.push(createScope(name, type, path, netlistId, scopeOffsetIdx, this.uri));
  }

  /**
   * Called by fsdbWorker when finished traversing a scope. Must be paired with a fsdbScopeCallback.
   */
  fsdbUpscopeCallback() {
    // Operate treeData as a stack
    const scope = this.treeData.pop()!;
    if (this.treeData.length === this.fsdbTopModuleCount) {
      // Is top level module
      this.treeData.push(scope);
      this.fsdbTopModuleCount++;
    } else {
      this.treeData[this.treeData.length - 1].children.push(scope);
    }
  }

  /**
  * Called by fsdbWorker when traversing a var.
  */
  fsdbVarCallback(name: string, type: string, encoding: string, path: string, netlistId: NetlistId, signalId: SignalId, width: number, msb: number, lsb: number) {
    const enumType = "";
    const paramValue = "";
    const varItem = createVar(name, paramValue, type, encoding, path, netlistId, signalId, width, msb, lsb, enumType, true /*isFsdb*/, this.uri);
    this.fsdbCurrentScope!.children.push(varItem);

    this.netlistIdTable[varItem.netlistId] = varItem;
  }

  fsdbArrayBeginCallback(name: string, path: string, netlistId: number) {
    this.fsdbCurrentScope!.children.push(createScope(name, "vhdlarray", path, netlistId, -1, this.uri));
  }

  fsdbArrayEndCallback(size: number) {
    const arrayElements = [];
    for (let i = 0; i < size; i++) {
      const element = this.fsdbCurrentScope!.children.pop()!;
      arrayElements.push(element);
    }
    // const array = this.children[this.children.length - 1];
    const array = this.fsdbCurrentScope!.children.pop()!; // The last item would be the scope item for the array
    array.children.push(...arrayElements.reverse());
    array.fsdbVarLoaded = true;
    this.fsdbCurrentScope!.children.unshift(array); // Move to front to align with wellen
  }
}
